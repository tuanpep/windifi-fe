name: CI/CD Pipeline

on:
  push:
    branches: [develop, main]
  pull_request:
    branches: [develop, main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1

jobs:
  # Code Quality and Testing
  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.deploy-check.outputs.should-deploy }}
      environment: ${{ steps.deploy-check.outputs.environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run type-check

      - name: Run tests with coverage
        run: npm run test:run

      - name: Run format check
        run: npm run format:check

      - name: Security audit
        run: npm audit --audit-level moderate

      - name: Determine deployment
        id: deploy-check
        run: |
          if [[ "${{ github.event_name }}" == "push" ]]; then
            if [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "environment=develop" >> $GITHUB_OUTPUT
            elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "environment=production" >> $GITHUB_OUTPUT
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

  # Build and Push Docker Image
  build:
    name: Build & Push Image
    needs: quality-gate
    runs-on: ubuntu-latest
    if: needs.quality-gate.outputs.should-deploy == 'true'

    permissions:
      contents: read
      packages: write
      security-events: write

    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha,scope=${{ github.ref_name }}
            type=gha,scope=refs/heads/main
          cache-to: type=gha,mode=max,scope=${{ github.ref_name }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1

  # Deploy to Server
  deploy:
    name: Deploy to ${{ needs.quality-gate.outputs.environment }}
    needs: [quality-gate, build]
    runs-on: ubuntu-latest
    if: needs.quality-gate.outputs.should-deploy == 'true'

    environment:
      name: ${{ needs.quality-gate.outputs.environment }}
      url: ${{ steps.deploy.outputs.url }}

    steps:
      - name: Checkout compose files
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            docker-compose.yml
            docker-compose.prod.yml
          sparse-checkout-cone-mode: false

      - name: Setup SSH with security hardening
        run: |
          # Create SSH directory with proper permissions
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Add SSH private key with proper permissions
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Configure SSH client for security
          cat > ~/.ssh/config << EOF
          Host deployment-server
            HostName ${{ secrets.SERVER_HOST }}
            User ${{ secrets.SERVER_USER }}
            IdentityFile ~/.ssh/id_rsa
            StrictHostKeyChecking yes
            UserKnownHostsFile ~/.ssh/known_hosts
            ServerAliveInterval 60
            ServerAliveCountMax 3
            ConnectTimeout 10
          EOF
          chmod 600 ~/.ssh/config

          # Add server to known hosts
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Pre-deployment validation
        run: |
          echo "üîç Running pre-deployment validation..."

          # Test SSH connectivity
          ssh deployment-server "echo 'SSH connection successful'"

          # Check server resources
          ssh deployment-server "
            echo 'Server resources:'
            df -h /
            free -h
            docker system df
          "

      - name: Deploy with docker-compose
        id: deploy
        run: |
          echo "üöÄ Starting deployment to ${{ needs.quality-gate.outputs.environment }}..."

          # Extract image tag
          IMAGE_TAG=$(echo "${{ needs.build.outputs.image-tags }}" | grep -E "${{ needs.quality-gate.outputs.environment }}-" | head -1)

          # Set environment-specific variables
          if [[ "${{ needs.quality-gate.outputs.environment }}" == "production" ]]; then
            APP_PORT=80
            COMPOSE_FILE="docker-compose.prod.yml"
            SERVICE_NAME="windifi-fe"
          else
            APP_PORT=3000
            COMPOSE_FILE="docker-compose.yml"
            SERVICE_NAME="windifi-fe"
          fi

          # Ensure deployment directory exists and copy compose files
          ssh deployment-server "mkdir -p ~/windifi-fe-deploy"
          scp docker-compose*.yml deployment-server:~/windifi-fe-deploy/

          ssh deployment-server "
            export IMAGE_TAG='$IMAGE_TAG'
            export COMPOSE_FILE='$COMPOSE_FILE'
            export APP_PORT='$APP_PORT'
            
            set -e
            echo 'üîÑ Deploying image:' \$IMAGE_TAG
            
            cd ~/windifi-fe-deploy
            
            # Create environment file
            echo 'IMAGE_TAG='\$IMAGE_TAG > .env
            echo 'APP_PORT='\$APP_PORT >> .env
            echo 'NODE_ENV=production' >> .env
            echo 'GITHUB_REPOSITORY=${{ env.IMAGE_NAME }}' >> .env
            echo 'CONTAINER_NAME=windifi-fe-${{ needs.quality-gate.outputs.environment }}' >> .env
            
            docker pull \$IMAGE_TAG
            
            echo 'üì¶ Stopping current containers...'
            docker-compose -f \$COMPOSE_FILE down --remove-orphans || true
            
            echo 'üöÄ Starting new containers...'
            docker-compose -f \$COMPOSE_FILE up -d
            
            echo '‚è≥ Waiting for container to start...'
            sleep 15
            
            if ! docker-compose -f \$COMPOSE_FILE ps | grep -q 'Up'; then
              echo '‚ùå Container failed to start'
              docker-compose -f \$COMPOSE_FILE logs
              exit 1
            fi
            
            echo '‚úÖ Container started successfully'
          "

          # Set output URL
          if [[ "${{ needs.quality-gate.outputs.environment }}" == "production" ]]; then
            echo "url=http://${{ secrets.SERVER_HOST }}" >> $GITHUB_OUTPUT
          else
            echo "url=http://${{ secrets.SERVER_HOST }}:3000" >> $GITHUB_OUTPUT
          fi

      - name: Health check and validation
        run: |
          echo "üè• Running health checks..."

          # Set environment-specific variables
          if [[ "${{ needs.quality-gate.outputs.environment }}" == "production" ]]; then
            HEALTH_URL="http://${{ secrets.SERVER_HOST }}/api/health"
            COMPOSE_FILE="docker-compose.prod.yml"
          else
            HEALTH_URL="http://${{ secrets.SERVER_HOST }}:3000/api/health"
            COMPOSE_FILE="docker-compose.yml"
          fi

          # Wait for application to be ready (reduced attempts)
          echo "‚è≥ Waiting for application to be ready..."
          for i in {1..6}; do
            if curl -f -s "$HEALTH_URL" >/dev/null 2>&1; then
              echo "‚úÖ Health check passed on attempt $i"
              HEALTH_RESPONSE=$(curl -s "$HEALTH_URL")
              echo "Health response: $HEALTH_RESPONSE"
              exit 0
            fi
            if [ $i -eq 6 ]; then
              echo "‚ùå Health check failed after 6 attempts"
              ssh deployment-server "cd ~/windifi-fe-deploy && docker-compose -f $COMPOSE_FILE logs --tail=50"
              exit 1
            fi
            echo "‚è≥ Health check attempt $i failed, retrying in 10s..."
            sleep 10
          done

      - name: Post-deployment cleanup
        if: success()
        run: |
          echo "üßπ Running post-deployment cleanup..."

          ssh deployment-server << 'EOF'
            cd ~/windifi-fe-deploy
            
            # Clean up old images (keep last 3)
            docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
              grep "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" | \
              tail -n +4 | \
              awk '{print $1}' | \
              xargs -r docker rmi || true
            
            # Clean up dangling images and unused volumes
            docker image prune -f
            docker volume prune -f
            
            echo "‚úÖ Cleanup completed"
          EOF

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîÑ Rolling back due to deployment failure..."

          ssh deployment-server << 'EOF'
            cd ~/windifi-fe-deploy
            
            # Stop failed containers
            echo "üì¶ Stopping failed containers..."
            docker-compose down --remove-orphans || true
            
            echo "‚ö†Ô∏è  Deployment failed - manual intervention may be required"
            echo "Check logs with: docker-compose logs"
          EOF

      - name: Deployment summary
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment to ${{ needs.quality-gate.outputs.environment }} successful!"
            echo "üåê Application available at: ${{ steps.deploy.outputs.url }}"
            echo "üìä Health endpoint: ${{ steps.deploy.outputs.url }}/api/health"
          else
            echo "‚ùå Deployment to ${{ needs.quality-gate.outputs.environment }} failed!"
            echo "üîÑ Rollback has been attempted"
          fi
